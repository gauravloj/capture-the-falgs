"""
$ curl -sO https://artifacts.picoctf.net/c_titan/82/crackme100

---
Running the binary will ask for a password.
Goal is to find the password.

---
Open the binary using cutter (or any reverse engineering tool)
And see the decompiled code.


Here is the decompiled code generated by cutter:


// WARNING: [rz-ghidra] Detected overlap for variable var_2ch
// WARNING: [rz-ghidra] Detected overlap for variable fix
#include <stdio.h>
#include <string.h>

int main(void) {
  unsigned int uVar1;
  int32_t iVar2;
  char input[51];
  char *output = "apijaczhzgtfnyjgrdvqrjbmcurcmjczsvbwgdelvxxxjkyigy";
  int64_t var_28h;
  int secret3;
  int secret2;
  int secret1;
  int len;
  short int src_idx;
  int i;

  setvbuf(stdout, 0, 2, 0);
  printf("Enter the secret password: ");
  scanf("%50s", input);
  i = 0;
  len = strlen(output);
  secret1 = 0x55;
  secret2 = 0x33;
  secret3 = 0xf;
  var_28h._7_1_ = 'a';
  for (; i < 3; i = i + 1) {
    for (src_idx = 0; src_idx < len; src_idx = src_idx + 1) {
      uVar1 = (src_idx >> 1 & secret1) + (src_idx & secret1);
      uVar1 = (uVar1 >> 2 & secret2) + (secret2 & uVar1);
      iVar2 = (uVar1 >> 4 & secret3) + (input[src_idx] - var_28h._7_1_) +
              (secret3 & uVar1);
      input[src_idx] = var_28h._7_1_ + (char)iVar2 + (char)(iVar2 / 26) * -26;
    }
  }
  iVar2 = memcmp(input, output, SEXT48(len));
  if (iVar2 == 0) {
    printf("SUCCESS! Here is your flag: %s\n", "picoCTF{sample_flag}");
  } else {
    puts("FAILED!");
  }
  return 0;
}

----


Below python code is the reverse engineered code of the binary.
Function decrypt_offset represents the decryption logic inside the for loop.

So if we encrypt the given output_str (in the decompiled code) it will be the expected password.

The encrypt_offset function is the reverse of the decrypt_offset function.
Hence, encrypt(output) is the expected password

---
Running this script will print:
output: apijaczhzgtfnyjgrdvqrjbmcurcmjczsvbwgdelvxxxjkyigy
cipher: amfdxwtywanwhpauoxphlasawliqdxqkppvnauvzpoolaymtap

---

Testing the password with th eprovided binary:

$ echo -n 'amfdxwtywanwhpauoxphlasawliqdxqkppvnauvzpoolaymtap' | ./crackme100 

> Enter the secret password: SUCCESS! Here is your flag: picoCTF{sample_flag}

---

Testing on actual challenge:
$ echo -n 'amfdxwtywanwhpauoxphlasawliqdxqkppvnauvzpoolaymtap' | nc titan.picoctf.net 58130

> Enter the secret password: SUCCESS! Here is your flag: picoCTF{s0lv3_angry_symb0ls_e1ad09b7}


"""

len_out = 50

def gen_offset():
    secret1 = 0x55
    secret2 = 0x33
    secret3 = 0xf
    offset = []
    for src_idx in range(len_out):
        uVar1 = (src_idx >> 1 & secret1) + (src_idx & secret1)
        uVar2 = (uVar1 >> 2 & secret2) + (secret2 & uVar1)
        iVar2 = (uVar2 >> 4 & secret3) + (secret3 & uVar2)
        offset.append(iVar2)

    return offset

offset_list = gen_offset()


def decrypt_offset(input_str):
    basechar = ord('a')
    newstr = ""
    for _ in range(3):
        newstr = ""
        for src_idx in range(len_out):
            offset = offset_list[src_idx]  + ord(input_str[src_idx]) - basechar
            newstr += chr(basechar + (offset % 26))
        input_str = newstr
    return newstr


def encrypt_offset(input_str):
    basechar = ord('a')
    newstr = ""
    for _ in range(3):
        newstr = ""
        for src_idx in range(len_out):
            offset = ord(input_str[src_idx]) - basechar - offset_list[src_idx]
            newstr += chr(basechar + (offset % 26))
        input_str = newstr
    return newstr

    

if __name__ == "__main__":
    # sample_input = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwx"
    # encryyptstr = encrypt_offset(sample_input)
    # decrypt_str = decrypt_offset(encryyptstr)
    # print("Original: ", sample_input)
    # print("Offset encrypt: ", encryyptstr)
    # print("Offset decrypt: ", decrypt_str)
    # exit()

    output = "apijaczhzgtfnyjgrdvqrjbmcurcmjczsvbwgdelvxxxjkyigy"
    cipher = encrypt_offset(output)
    print(f"output: {output}")
    print(f"cipher: {cipher}")
